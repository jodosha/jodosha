name: "üì° Update Social Feeds"

on:
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours
  workflow_dispatch:

jobs:
  update-feeds:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          
      - name: Fetch All Social Feeds
        run: |
          echo "Fetching social feeds from all platforms..."
          
          # Install required dependencies
          npm install -g xml2js cheerio
          
          # Create comprehensive feed aggregator script
          node -e "
          const fs = require('fs');
          const https = require('https');
          const http = require('http');
          
          const socialConfig = JSON.parse(fs.readFileSync('data/social.json', 'utf8'));
          const feeds = socialConfig.feeds;
          
          const fetchURL = (url) => {
            return new Promise((resolve, reject) => {
              const client = url.startsWith('https') ? https : http;
              const req = client.get(url, {
                headers: {
                  'User-Agent': 'Mozilla/5.0 (compatible; FeedBot/1.0)',
                  'Accept': 'application/rss+xml, application/xml, text/xml, text/html'
                }
              }, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => resolve({ status: res.statusCode, data }));
              });
              req.on('error', reject);
              req.setTimeout(10000, () => {
                req.destroy();
                reject(new Error('Timeout'));
              });
            });
          };
          
          const parseRSS = (xmlData) => {
            const items = [];
            try {
              // Simple RSS parsing without external dependencies
              const itemMatches = xmlData.match(/<item[^>]*>[\s\S]*?<\/item>/gi) || [];
              
              itemMatches.forEach(item => {
                const titleMatch = item.match(/<title><!\[CDATA\[(.*?)\]\]><\/title>|<title>(.*?)<\/title>/i);
                const linkMatch = item.match(/<link>(.*?)<\/link>/i);
                const dateMatch = item.match(/<pubDate>(.*?)<\/pubDate>|<published>(.*?)<\/published>/i);
                const descMatch = item.match(/<description><!\[CDATA\[(.*?)\]\]><\/description>|<description>(.*?)<\/description>/i);
                
                if (titleMatch && linkMatch) {
                  const title = (titleMatch[1] || titleMatch[2] || '').trim();
                  const link = linkMatch[1].trim();
                  const pubDate = dateMatch ? (dateMatch[1] || dateMatch[2] || '') : '';
                  const description = descMatch ? (descMatch[1] || descMatch[2] || '') : '';
                  
                  items.push({
                    title,
                    link,
                    pubDate,
                    description: description.substring(0, 200) + (description.length > 200 ? '...' : ''),
                    date: pubDate ? new Date(pubDate) : new Date()
                  });
                }
              });
            } catch (e) {
              console.error('RSS parsing error:', e.message);
            }
            return items;
          };
          
          const scrapeBasicInfo = (htmlData, platform) => {
            // Basic scraping for platforms without RSS
            const items = [];
            try {
              if (platform === 'linkedin') {
                // LinkedIn activity placeholder
                items.push({
                  title: 'Recent LinkedIn activity',
                  link: 'https://linkedin.com/in/lucaguidi/recent-activity/',
                  pubDate: new Date().toISOString(),
                  description: 'Professional updates and network activity',
                  date: new Date()
                });
              } else if (platform === 'x') {
                // X/Twitter placeholder
                items.push({
                  title: 'Latest tweets and thoughts',
                  link: 'https://x.com/jodosha',
                  pubDate: new Date().toISOString(),
                  description: 'Tech insights and development updates',
                  date: new Date()
                });
              } else if (platform === 'instagram') {
                // Instagram placeholder
                items.push({
                  title: 'Creative content and music',
                  link: 'https://instagram.com/jodosha',
                  pubDate: new Date().toISOString(),
                  description: 'Visual content and music production',
                  date: new Date()
                });
              }
            } catch (e) {
              console.error('Scraping error for', platform, ':', e.message);
            }
            return items;
          };
          
          const processSingleFeed = async (feed) => {
            console.log('Processing:', feed.name);
            
            try {
              const response = await fetchURL(feed.url);
              
              if (response.status === 200 && response.data) {
                let items = [];
                
                if (feed.type === 'rss') {
                  items = parseRSS(response.data);
                } else if (feed.type === 'scrape') {
                  items = scrapeBasicInfo(response.data, feed.platform);
                }
                
                // Add platform metadata to each item
                items.forEach(item => {
                  item.platform = feed.platform;
                  item.platform_name = feed.name;
                  item.profile_url = feed.profile_url;
                });
                
                console.log('‚úì Successfully fetched', items.length, 'items from', feed.name);
                return { success: true, items, error: null };
              } else {
                console.warn('‚ö† HTTP error for', feed.name, '- Status:', response.status);
                return { success: false, items: [], error: 'HTTP ' + response.status };
              }
            } catch (error) {
              console.error('‚úó Error processing', feed.name, ':', error.message);
              return { success: false, items: [], error: error.message };
            }
          };
          
          const createFallbackItem = (feed, error = null) => {
            const errorSuffix = error ? ' (connection issue)' : '';
            return {
              title: 'Recent activity on ' + feed.name + errorSuffix,
              link: feed.profile_url,
              pubDate: new Date().toISOString(),
              description: error ? 
                'Content temporarily unavailable - check back later' : 
                'Latest updates and content',
              date: new Date(),
              platform: feed.platform,
              platform_name: feed.name,
              profile_url: feed.profile_url,
              is_fallback: true,
              error: error
            };
          };
          
          const processFeeds = async () => {
            const allItems = [];
            const feedResults = [];
            let successCount = 0;
            let fallbackCount = 0;
            
            // Process all feeds in parallel for better performance
            const feedPromises = feeds.map(feed => 
              processSingleFeed(feed).catch(error => {
                console.error('Unhandled error for', feed.name, ':', error);
                return { success: false, items: [], error: error.message };
              })
            );
            
            const results = await Promise.allSettled(feedPromises);
            
            // Process results and create items
            for (let i = 0; i < results.length; i++) {
              const result = results[i];
              const feed = feeds[i];
              
              if (result.status === 'fulfilled' && result.value.success && result.value.items.length > 0) {
                // Successful fetch with items
                allItems.push(...result.value.items);
                feedResults.push({ feed: feed.name, status: 'success', count: result.value.items.length });
                successCount++;
              } else {
                // Failed fetch or no items - create fallback
                const error = result.status === 'rejected' ? 
                  result.reason?.message || 'Unknown error' : 
                  result.value?.error || 'No items found';
                
                const fallbackItem = createFallbackItem(feed, error);
                allItems.push(fallbackItem);
                feedResults.push({ feed: feed.name, status: 'fallback', error });
                fallbackCount++;
              }
            }
            
            // Sort by date in reverse chronological order
            allItems.sort((a, b) => new Date(b.date) - new Date(a.date));
            
            // Take latest 20 items
            const latestItems = allItems.slice(0, 20);
            
            // Generate summary
            console.log('\\nüìä Feed Processing Summary:');
            console.log('‚úì Successful feeds:', successCount);
            console.log('‚ö† Fallback feeds:', fallbackCount);
            console.log('üìù Total items:', latestItems.length);
            
            feedResults.forEach(result => {
              if (result.status === 'success') {
                console.log('  ‚úì', result.feed, '- fetched', result.count, 'items');
              } else {
                console.log('  ‚ö†', result.feed, '- using fallback:', result.error.substring(0, 50));
              }
            });
            
            // Write to feed.json with metadata
            const feedData = {
              updated: new Date().toISOString(),
              total_items: latestItems.length,
              successful_feeds: successCount,
              fallback_feeds: fallbackCount,
              feed_status: feedResults,
              items: latestItems
            };
            
            fs.writeFileSync('data/feed.json', JSON.stringify(feedData, null, 2));
            console.log('\\n‚úÖ Generated data/feed.json successfully');
            
            // The workflow continues even if some feeds fail
            // as long as we have at least one item per platform
            if (allItems.length === 0) {
              console.error('‚ùå No items generated from any platform');
              process.exit(1);
            }
          };
          
          processFeeds().catch(error => {
            console.error('‚ùå Critical error in feed processing:', error);
            
            // Create minimal fallback feed.json even on complete failure
            const fallbackData = {
              updated: new Date().toISOString(),
              total_items: 0,
              successful_feeds: 0,
              fallback_feeds: feeds.length,
              error: error.message,
              items: feeds.map(feed => ({
                title: 'Service temporarily unavailable - ' + feed.name,
                link: feed.profile_url,
                pubDate: new Date().toISOString(),
                description: 'Feed processing encountered an error. Please check back later.',
                date: new Date(),
                platform: feed.platform,
                platform_name: feed.name,
                profile_url: feed.profile_url,
                is_fallback: true,
                error: 'Processing failed'
              }))
            };
            
            fs.writeFileSync('data/feed.json', JSON.stringify(fallbackData, null, 2));
            console.log('üìù Created fallback feed.json');
            
            // Don't fail the workflow - we still produced output
            process.exit(0);
          });
          "
          
      - name: Commit Feed Updates
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add data/feed.json
          git diff --staged --quiet || git commit -m "üì° Update social feeds"
          git push